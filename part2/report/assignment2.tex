\documentclass[12pt,a4paper]{article}
\usepackage[parfill]{parskip}
\usepackage{fullpage}
\usepackage{enumitem}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{subfig}
\usepackage{amsmath}
\begin{document}

\vfil

\begin{center}
	{\Large Mobile Robot Systems} \\
	\vspace{0.4in}
	{\huge \bf Assignment 2} \\
	\vspace{0.4in}
	{\large Anik Roy} \\
	\vspace{0.1in}
	{\large \today} \\
\end{center}
\vspace{0.4in}

% Main document

\section*{1.1 Potential Field Method}
\subsection*{Exercise 1}
\begin{enumerate}[label=(\alph*)]
	\item The plot of the potential field for moving towards the goal can be seen in figure \ref{fig:goal_mode}. This field is calculated by taking the vector from the position towards the goal, and squaring the magnitude of the vector while keeping the same direction. This ensures that the robot 'slows down' as it gets closer to the goal, and that it will always attempt to move towards the goal. The figure shows how all the vectors point towards the goal, and that vectors close to the goal have a smaller magnitude
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/1a.png}
		\caption{Potential field with the goal}
		\label{fig:goal_mode}
	\end{figure}
	\item In order to avoid obstacles, we also need to find a vector field which will let us move away from obstacles (a field that is repulsive). In order to do this, I first find the distance from the position to the surface of the  obstacle by finding the euclidean distance and subtracting the radius. Since positions closer to the obstacle should be more 'repulsive', the reciprocal of this distance is the magnitude of the final vector. The direction of the final vector is directly away from the centre of the obstacle towards the robot. I also scale this by a tunable parameter to ensure the robot makes progress. This process is repeated for each obstacle, and the vectors produced are summed so that all the obstacles are taken into account. The resulting vector is also capped to a maximum speed.
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/1b.png}
		\caption{Potential field with the obstacles}
		\label{fig:obs_mode}
	\end{figure}
	\item Figure \ref{fig:all_mode} shows how combingin the two vector fields results in a new field which allows the robot to take a path to the goal while avoiding the obstacle. Since the vectors from the obstacle have a repulsive effect, and the vectors towards the goal have an attactive effect, they combine these effects to create vectors which go towards the goal but also away from the obstacle.
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/1c.png}
		\caption{Potential field with both the goals and the obstacle}
		\label{fig:all_mode}
	\end{figure}
	\item In the previous part, the obstacle was at the position (0.2,0.3). Since the robot started at (-1.5,-1.5), and the vectors for the goal are direct, they will pass directly through the center of the obstacle. The vectors from the obstacle are in the opposite direction, as the direction of these vectors is the direction from the robot to the obstacle flipped. This means they will cancel each other out to produce a zero vector somewhere between the start position and the obstacle, stopping the robot. This can be seen in \ref{fig:failed_potential}, where the robot gets stuck halfway between the start and the obstacle. One possible solution is to change the direction of the vectors coming from the obstacle. Currently, they are directly in the direction of the robot, but they could be made to be skewed slightly so that the robot would always move in one direction. Once the robot moves in the direction, vectors towards the goal should allow the robot to keep moving. This still ensures the robot does not hit the obstacle, since the vectors are still repulsive, just in a slightly different direction.
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/1d.png}
		\caption{Potential field with the obstacle at (0,0)}
		\label{fig:failed_potential}
	\end{figure}
	\item Figure \ref{fig:fixed_potential} shows how the problem in part (d) can be fixed. The vectors coming from the obstacle are now rotated by 1 radian anti-clockwise (which can be tuned). This means that the robot will now take the path on the right of the obstacle, as it is pushed in that direction by these vectors. To calculate the vectors, I use the standard 2-D rotation matrix to ensure that the magnitude of the vector stays the same (it is rotated from its original direction around its base).
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/1e.png}
		\caption{Potential field with the obstacle at (0,0), fixed}
		\label{fig:fixed_potential}
	\end{figure}
	\item The solution from part (e) still works with two obstacles, with the robot taking a similar path as it is repulsed from both the obstacles.
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/1f.png}
		\caption{Potential field with two obstacles at (0,0.5) and (0.5,0)}
		\label{fig:fixed_potential}
	\end{figure}
	
\end{enumerate}
\subsection*{Exercise 2}
\begin{enumerate}[label=(\alph*)]
	\item The equations for feedback linearization:
		$$\dot{x_p} = u\cos{\theta} - \epsilon \omega \sin{\theta}$$
		$$\dot{y_p} = u\sin{\theta} + \epsilon \omega \cos{\theta}$$
		Rearranged for $u$ and $\omega$:
		$$ u =x_p\cos{\theta} + y_p\sin{\theta} $$
		$$ \omega = {(-x_p\sin{\theta}+y\cos{\theta})\over{\epsilon}}$$
	\item The point of feedback linearisation is to allow a non-holonomic robot to appear to move holonomically, by controlling a holonomic point and calculating how the robot would move as if 'pulled' by that point.
	\item The plot below shows the trajectory of the robot as it navigates from the start to the goal.
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/2c.png}
		\caption{Trajectory of robot in potential field}
		\label{fig:trajectory}
	\end{figure}
	\item
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/2d.png}
		\caption{Trajectory of robot in potential field, using relative position}
		\label{fig:trajectory}
	\end{figure}

\end{enumerate}

\section*{1.2 Rapidly\-Exploring Random Trees}

\subsection*{Exercise 3}
\begin{enumerate}[label=(\alph*)]
	\item The \texttt{sample\_random\_position} method finds a random position that is not occupied (or unknown) within the occupancy grid. It does this by finding the size of the array (\texttt{grid.values}) backing the grid object, and from this calculating the possible positions in world coordinates that the grid represents. The \texttt{get\_position} method of the grid allows us to find the position encoded by the first (top left, index [0,0]) and last (bottom right, index [len(grid), len(grid[0])]) elements of the occupancy grid. From this we have the set of coordinates we can sample from - we have the maximum and minimum for both x and y coordinated. We then sample uniformly from this range (both x and y), and check if that position is free. We continue sampling until we find a position that is free.
	\item The method of Rapidly exploring Random Trees (RRT) is used to plan a path to the goal. This method samples random points in the free space and attempts to connect the point to other points to build up a tree which explores the area of the free space. Figure \ref{fig:rrt} shows paths generated by my rrt method.
	\begin{figure}[h!]
		\centering
		\subfloat{{\includegraphics[width=7cm]{fig/3b.png}}}%
		\qquad
		\subfloat{{\includegraphics[width=7cm]{fig/3b_1.png}}}%
		\caption{Paths generated by RRT}		
		\label{fig:rrt}%
		\end{figure}

	\item RRT will often find a suboptimal path due to the fact the the random points that are sampled will just be connected to the closest pre-existing node. This closest point may not always be the best point to connect to, since the path to that node may be longer that it needs to be. A solution is to use the RRT* algorithm, accumulating `costs', which represent the distance taken by the shortest path from the root to the node. We can then connect to the nodes with the least cost rather than just the nearest neighbour. We can also carry out a `rewiring' step, which will use the new node generated to find shorter paths for nearby nodes, changing the parent of nearby nodes to the new node if using the new node will reduce the cost to the nearby nodes. This ensures shorter paths are created from the new randomly generated position.
	\item Figure \ref{fig:rrt-star} shows the implementation of RRT* generating shorter and smoother paths.
	\begin{figure}[h!]
		\centering
		\subfloat{{\includegraphics[width=7cm]{fig/3d.png}}}%
		\qquad
		\subfloat{{\includegraphics[width=7cm]{fig/3d_1.png}}}%
		\caption{Paths generated by RRT*}		
		\label{fig:rrt-star}%
	\end{figure}


\end{enumerate}
\subsection*{Exercise 4}
\begin{enumerate}[label=(\alph*)]
	\item Feedback linearized is implemented here the same as in exercise 2
	\item Motion primitives can be used to generate edges for non-holonomic robots. This means we don't have to solve a boundary value problem (differential equations) to generate edges which are valid trajectories for non-holonomic robots. However, it does mean that the paths we generate are not always the best paths to take.
	\item The \texttt{get\_velocity} method generates a velocity vector based on a robot position and a set of points which represent the desired trajectory of the robot. First, it finds the point on the path which is closest to the position of the robot. The subsequent point on the path is the direction in which the velocity is, since we want to make sure the robot gets closer to the desired path. If the closest point is the point at the end of the path, then the vector is just in that direction (avoiding an index being out of bounds). Figure \ref{fig:rrt-slam} shows how a path is generated by rrt, which the robot then follows using \texttt{get\_velocity} and \texttt{feedback\_linearized}
	\begin{figure}[!h]
		\centering
		\includegraphics[width=\textwidth]{fig/4c.png}
		\caption{RViz window showing RRT with SLAM}
		\label{fig:rrt-slam}
	\end{figure}
	\item SLAM
	\item 
\end{enumerate}


\end{document}
